# I/O多路复用

> **单线程或单进程同事监测若干文件描述符是否可以执行I/O操作的能力。**

## 并发

> **逻辑控制流在时间上的重叠叫做并发**

由于CPU在同一时间只能做一件事儿，因此存在以下解决方案
1. 时分复用（多个事件流将CPU切割成多个时间片，不同事件流的时间片交替进行）- **多线程/进程**实现
2. I/O多路复用 - **单线程/进程实现**

## Linux I/O模型
1. 阻塞I/O
2. 非阻塞I/O
3. I/O多路复用
4. 信号驱动I/O
5. 异步I/O

## 阻塞I/O
发起一次I/O操作后一直等待成功或失败之后才返回，在这期间程序不能做其他的事情。阻塞I/O操作只能对单个文件描述符进行操作。

## 非阻塞I/O
我们在发起I/O时，对文件描述符设置O_NONBLOCK flag来指定该文件描述符的I/O操作为非阻塞，非阻塞I/O通常发生在一个for循环当中，因为每次进行I/O操作时要么I/O操作成功，要么当I/O操作会阻塞时返回错误EWOULDBLOCK/EAGAIN，然后再根据需要进行下一次的for循环操作，这种类似轮询的方式会浪费很多不必要的CPU资源，是一种糟糕的设计。和阻塞IO一样，非阻塞IO也是通过调用read或writewrite来进行操作的，也只能对单个描述符进行操作。

## I/O多路复用
I/O多路复用在Linux下包括了三种：select, poll, epoll抽象来看，他们的功能是类似的，但具体细节各有不同：首先都会对一组文件描述符进行相关事件的注册，然后阻塞等待某些事件的发生或等待超时。但对于这三种机制而言，不同数量级文件描述符对性能的影响是不同的.

## 信号驱动I/O
信号驱动I/O是利用信号机制，让内核告知应用程序文件描述符相关事件。

但信号驱动I/O在网络编程的时候通常很少用到，因为在网络环境中，和socket相关的读写事件太多了，比如下面的事件都会导致SIGIO信号的产生：

1. TCP连接建立
2. 一方断开TCP连接请求
3. 断开TCP连接请求完成
4. TCP连接半关闭
5. 数据到达TCP socket
6. 数据已经发送出去(如：写buffer有空余空间)

上面所有的这些都会产生SIGIO信号，但我们没办法在SIGIO对应的信号处理函数中区分上述不同的事件，SIGIO只应该在IO事件单一情况下使用，比如说用来监听端口的socket，因为只有客户端发起新连接的时候才会产生SIGIO信号。

## 异步I/O

异步I/O与信号驱动I/O差不多，但它比信号驱动I/O可以多一步：相比信号驱动I/O需要在程序中完成数据从用户态的拷贝，异步I/O可以把拷贝这一步也帮我们完成之后才通知应用程序。

## 解决方案

Linux：select、poll、epoll

MacOS/FreeBSD：kqueue

Windows/Solaries： IOCP

## 常见的I/O多路复用解决方案

redis: Linux下 epoll(level-triggered)，没有epoll用select

nginx: Linux下 epoll(edge-triggered)，没有epoll用select

## Node通过libuv来统一*nix和windows平台

通过以上方案实现异步I/O


