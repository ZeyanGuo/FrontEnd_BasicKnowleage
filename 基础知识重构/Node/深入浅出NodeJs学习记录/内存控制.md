# 内存控制

由于Node需要长时间的运行于Node服务器，因此会存在大量的请求或长时间运行，那么相较于以前的短时间执行场景，Node不得不对内存进行控制。

## V8的垃圾回收机制和内存限制

Node在使用内存时只有部分内存可以使用，64位系统下约为1.4GB、32位系统下约为0.7GB。

Node环境下内存无法直接操作大内存对象，比如无法将一个2GB的文件读入内存中进行字符串分析处理。即使在32G物理内存的情况下，计算机内存资源依旧无法充分使用。

Node可以在启动时就传递--max-old-space-size或--max-new-space-size来调整内存限制的大小，示例如下：

node --max-old-space-size=1700 test.js //单位为MB
node --max-new-space-size=1024 test.js //单位为KB

## V8的垃圾回收机制

### v8的主要垃圾回收算法

V8主要使用分代式垃圾回收方法，

在V8中主要将内存分为新生代和老生代两代，新生代中的对象为存活时间较短的对象，老生代的对象为存活时间较长或者常驻内存的对象。

--max-old-space-size用于设置老生代内存空间大小

--max-new-space-size用于设置新生代内存空间大小

---

**Scavenge**算法

在分代的基础上，新生代的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法

> Cheney算法将堆内存一分为二，每一个空间称为semispace，在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。使用中的空间称为From空间，闲置状态称为To空间。当垃圾回收开始时，会检查From空间中的存活对象，这些存活对象会被复制到To空间中，而非存活对象占用的空间将会被释放。完成后From空间和To空间的角色发送对换。

Scavenge算法缺点是只能使用堆空间中的一半，而且是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收中。但可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。


---
**新生代向老生代晋升**

新生代要向老生代晋升需要满足两个条件

1. 一个对象是否经历过Scavenge回收
2. To空间的内存占用比超过限制

---

**Mark-Sweep & Mark-Compact**算法

Mark-Sweep（标记清除）：分为标记和清除两个阶段，与Scavenge相比，Mark-Sweep并不将内存划分为两半，所以不存在浪费一半空间的行为。Mark-Sweep只会标记活着的对象，而只清除死亡对象，（Scavenge只复制活着的对象，Mark-Sweep只清理死亡的对象，活对象在新生代中只占小部分，死对象在老生代中只占小部分，这是两种回收方式能够高效处理的原因）

Mark-Compact（内存整理）：用于解决Mark-Sweep后造成的内存碎片

---
算法对比
|回收算法|Mark-Sweep|Mark-Compact|Scavenge|
|---|---|---|---|
|速度|中等|最慢|最快|
|空间开销|少（有碎片）|少（无碎片）|双倍空间（无碎片）|
|是否移动对象|否|是|是|

---

由于清理老生代过程中，可能会因为需要清理的数据太多而导致垃圾回收阶段造成长时间停顿，V8通过“增量标记”、“延时清理”、“增量整理”等手段来将一次标记清除过程划分成多个时间段，从而减少停顿时间到原本的1/6左右